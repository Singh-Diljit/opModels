"""Draw TOPM recomb."""

import numpy as np

#BERMUDA USES dT*i in excersiceDates

def drawTOPM(S, K, r, T, vol, q, depth=50,
             call=True, eu=False, am=False, be=False,
             exerciseDates=[]):
    """Print the tree generated by a BOPM of an option.
    
    Parameters
    ----------
    S       : float
    K       : float
    r       : float
    T       : float
    priceUp : float : func fixed with req. params so float
    probUp  : float : func fixed with req. params so float
    depth   : int
    call    : bool 
    levels  : int
    
    Returns
    -------
    A plot of binomial lattice and relevant data.
        
    Example(s)
    ----------
    >>>

    """
    #Check well-definedness of probability
    if depth < np.ceil(T/2 * (r - q)**2 / vol**2):
        raise ValueError(
            f'Need: depth >= {np.ceil(T/2*(r-q)**2/vol**2)}.')

    #Frequently used values
    dT = T / depth
    disc = np.exp(-r * dT)

    dT_ = dT/2
    drift = (r-q) * dT_
    noise = vol * np.sqrt(dT_)

    A = np.exp(drift + noise)
    B = np.exp(2*noise)
    norm = np.square(B - 1)
    
    pU = np.square(A - 1) / norm
    pD = np.square(B - A) / norm
    pS = 1 - pU - pD

    up = np.exp(vol * np.sqrt(2*dT))
    down = 1/up
    
    #Option Type
    if not any([eu, am, be]):
        european, american, bermuda = True, False, False
    else:
        european, american, bermuda = eu, am, be
    
    optType = ""
    if american:
        optType += 'American '
    elif european:
        optType += 'European '
    else:
        optType += 'Bermuda '
    if call: optType += 'call' if call else 'put'
    
    writtenData = (f"""
        ==========================BOPM========================

        |====================  PARAMETERS ====================
        |
        |K             : {K}                    
        |S0            : {S}
        |r             : {r}
        |T             : {T}
        |vol           : {vol}
        |div           : {q}
        |Option        : {optType}
        |height        : {depth}
        |exerciseDates : {exerciseDates}
        |
        |==================  Extracted Data ==================
        |
        |min height    : {np.ceil(T/2*(r-q)**2/vol**2)}
        |upFactor      : {up}
        |downFactor    : {down}
        |probUp        : {pU}
        |probStable    : {pS}
        |probDown      : {pD}
        |
        |=====================================================""")
    print(writtenData)
        
    #Value at expiry
    S *= up ** np.arange(-depth, depth+1, dtype=float)
    opPr = np.maximum(S - K, 0) if call else np.maximum(K - S, 0)
        
    #Value at earlier times
    for i in np.arange(depth-1, -1, -1):
        M = 2*i+1
        data = (f"""
        |==================  Level Data ==================
        |Height : {i+1}
        |Time   : {dT * (i+1)}
        |Nodes  : {M+2}""")
        print(data)
        print("        |" + ", ".join(str(round(x, 3)) for x in opPr[:M+2]))
        print("        |====================================================")
        opPr[:M] = disc * (pU*opPr[2:M+2] + pS*opPr[1:M+1] + pD*opPr[:M])

        if european:
            opPr = np.maximum(opPr[:M], 0)
        elif american or dT*i in exerciseDates:
            J = depth-i
            ex = np.maximum(S[J:-J]-K, 0) if call else np.maximum(K-S[J:-J], 0)
            opPr = np.maximum(opPr[:M], ex)

    data = (f"""
        |==================  Level Data ==================
        |Height : {0}
        |Time   : {0}
        |Nodes  : {1}""")
    print(data)
    print("        |" + str(round(opPr[0], 3)))
    print("        |====================================================")
    
    return opPr[0]

drawTOPM(100, 120, .05, .5, .2, 0, 5, call=False, am=True)
